/*
 * -----------------------
 * ------ SMART APP ------
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 

def clientVersion() {
    return "01.06.02"
}

/**
 * Chime and Notifications for Doorbells and Sensors
 *
 * Copyright RBoy Apps, redistribution, modification or reuse code is not allowed without permission
 * 2020-05-05 - (v01.06.02) Clarify repeat and after notifications and limit minimum value
 * 2020-05-04 - (v01.06.01) Try to detect platform outage and prevent code upgrade spam notifications
 * 2020-04-03 - (v01.06.00) Added option to skip first notification
 * 2020-03-20 - (v01.05.04) Fix for ST platform changes throwing an error on empty subscription
 * 2020-01-20 - (v01.05.03) Update icons for broken ST Android app 2.18
 * 2019-10-17 - (v01.05.02) Fix for push and silent notifications
 * 2019-10-11 - (v01.05.01) Add support for the new Sonos integration (auto detect)
 * 2019-06-28 - (v01.04.01) Added support for smoke, CO, water sensors and acceleration sensors
 * 2019-06-24 - (v01.03.02) Don't resume playback if no audio volume is specified
 * 2019-06-20 - (v01.03.01) Tell ST to use sentence capitalization for custom messages
 * 2019-06-11 - (v01.03.00) Added support for repeat notifications, checking devices on mode change and on app touch
 * 2019-06-06 - (v01.02.01) Added support for using custom volume levels for audio notification devices
 * 2019-06-04 - (v01.02.00) Added support for motion sensors
 * 2019-05-21 - (v01.01.01) Code clean up
 * 2019-05-20 - (v01.01.00) Added support for locks and button numbers (when supported by device)
 * 2019-05-01 - (v01.00.00) Initial release
 *
 */
definition(
    name: "Chimes and Notifications for Doorbells and Sensors",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Notify and ring a chime when a doorbell or sensor is triggered",
    parent: parent ? "rboy: Chimes and Doorbells" : null,
    singleInstance: true,
    category: "Safety & Security",
    iconUrl: "https://www.rboyapps.com/images/Chime.png",
    iconX2Url: "https://www.rboyapps.com/images/Chime.png"
)

preferences {
    page(name: "landingPage")
    page(name: "initPage")
    page(name: "summaryPage")
    page(name: "mainPage")
    page(name: "doorbellPage")
    page(name: "operatingPage")
    page(name: "notificationsPage")
    page(name: "scheduleCodesPage")
}

private getIsParent() { !parent }
private getIsParentInstalled() { state.parentInstalled }

def landingPage(params) {
    log.trace "Landing page isParent: $isParent, params: $params"
    
    if (!isParent) {
        mainPage()
    } else {
        if (isParentInstalled) {
            summaryPage()
        } else {
            initPage()
        }
    }
}

def initPage() {
    dynamicPage(name: "initPage", title: "Chimes & Notifications for Doorbells & Sensors v${clientVersion()}", install: true, uninstall: true) {
        section() {
            paragraph "Tap Save to finish installing Chimes and Doorbells then open it from your SmartApps to configure it"
        }
    }
}

def summaryPage() {
    dynamicPage(name: "summaryPage", title: "Chimes & Notifications for Doorbells & Sensors v${clientVersion()}", install: true, uninstall: true) {
        section() {
            app name: "newApp", appName: "Chimes and Notifications for Doorbells and Sensors", namespace: "rboy", title: "+ Add new rule", multiple: true, image: "https://www.rboyapps.com/images/Chime.png"
        }

        section() {
            input "updateNotifications", "bool", title: "Check for app updates", defaultValue: true, required: false
        }
    }
}

def mainPage() {
    dynamicPage(name: "mainPage", title: app.label ? "Configure rule" : "Setup new rule", install: true, uninstall: true) {
        TimeZone timeZone = location.timeZone
        if (!timeZone) {
            timeZone = TimeZone.getDefault()
            def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
            log.error msg
            sendPush msg
            section("INVALID HUB LOCATION") {
                paragraph title: msg, required: true, ""
            }
        }

        section() {
        	href(name: "doorbell", title: "Sensors and Triggers", page: "doorbellPage", description: "", required: false, image: "https://www.rboyapps.com/images/Triggers.png")
        	href(name: "notifications", title: "Chimes and Notifications", page: "notificationsPage", description: "", required: false, image: "https://www.rboyapps.com/images/NotificationsD.png")
        	href(name: "scheduling", title: "Operating Schedules and Modes", page: "operatingPage", description: "", required: false, image: "https://www.rboyapps.com/images/Scheduling.png")
    	}
        
        section() {
            label title: "Rule name", required: true
        }
    }
}

def doorbellPage() {
    dynamicPage(name: "doorbellPage", title: "", install: false, uninstall: false) {
        section("Notify when any of these sensors are triggered") {
            input "arrives", "capability.presenceSensor", title: "Arrives", multiple: true, required: false
            input "leaves", "capability.presenceSensor", title: "Leaves", multiple: true, required: false
            input "openContacts", "capability.contactSensor", title: "Sensors opened", multiple: true, required: false
            input "closeContacts", "capability.contactSensor", title: "Sensors closed", multiple: true, required: false
            input "unlockedLocks", "capability.lock", title: "Unlocked", multiple: true, required: false
            input "lockedLocks", "capability.lock", title: "Locked", multiple: true, required: false
            input "switchOn", "capability.switch", title: "Switched on", multiple: true, required: false
            input "switchOff", "capability.switch", title: "Switched off", multiple: true, required: false
            input "motionOn", "capability.motionSensor", title: "Motion detected", multiple: true, required: false
            input "waterSensors", "capability.waterSensor", title: "Water detected", multiple: true, required: false
            input "smokeSensors", "capability.smokeDetector", title: "Smoke detected", multiple: true, required: false
            input "coSensors", "capability.carbonMonoxideDetector", title: "CO detected", multiple: true, required: false
            input "accelSensors", "capability.accelerationSensor", title: "Vibration detected", multiple: true, required: false
            input "tampers", "capability.tamperAlert", title: "Tamper detected", multiple: true, required: false
            input "momentaries", "capability.momentary", title: "Momentary pressed", multiple: true, required: false
            input "pushButtons", "capability.button", title: "Buttons pressed", multiple: true, required: false, submitOnChange: true
            if (pushButtons) {
                input "pushButtonsNumbers", "enum", title: "...which button numbers", description: "Any", multiple: true, required: false, options: getButtonOptions()
            }
        }
        
        section("Recheck sensors when") {
            input "modeCheck", "bool", title: "Mode is changed", required: false
        }
    }
}

private getButtonOptions() {
    def options = [ "0":"Any" ] // Default any
    def maxButtons = 0
    pushButtons.each { dev -> // Select the device with the most buttons
        if (dev.currentValue("numberOfButtons")) {
            maxButtons = Math.max(maxButtons, dev.currentValue("numberOfButtons") as Integer)
        }
    }
    if (maxButtons) {
        options += (1..maxButtons).collectEntries { ["$it":"$it"] }
    }
    return options
}

def operatingPage() {
    dynamicPage(name: "operatingPage", title: "", install: false, uninstall: false) {
        TimeZone timeZone = location.timeZone
        if (!timeZone) {
            timeZone = TimeZone.getDefault()
            def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
            log.error msg
            sendPush msg
            section("INVALID HUB LOCATION") {
                paragraph title: msg, required: true, ""
            }
        }

        section("Operating Schedules and Modes") {
            mode title: "Enable system only when in this mode(s)", required: false, multiple: true, submitOnChange: false // Mode is now optional when we have operating schedules
            // 3 schedule options
            ('A'..'C').each { schedule ->
                def hrefParams = [
                    user: 1 as String,
                    schedule: schedule,
                    passed: true
                ]
                href(name: "schedule${schedule}", params: hrefParams, title: "Click here to define schedule ${schedule}", page: "scheduleCodesPage", description: (settings."userDayOfWeek${schedule}${1}" ? "${settings."userDayOfWeek${schedule}${1}"}: ${settings."userStartTime${schedule}${1}" ? (new Date(timeToday(settings."userStartTime${schedule}${1}", timeZone).time)).format("HH:mm z", timeZone) : ""} - ${settings."userEndTime${schedule}${1}" ? (new Date(timeToday(settings."userEndTime${schedule}${1}", timeZone).time)).format("HH:mm z", timeZone) : ""}" : "Not defined"), required: false)
            }
        }
    }
}

def notificationsPage() {
    dynamicPage(name: "notificationsPage", title: "", install: false, uninstall: false) {
        section("Ring") {
            input "chimes", "capability.tone", title: "Chimes(s)...", multiple: true, required: false, image: "https://www.rboyapps.com/images/ChimeGrey.png"
        }

        section("Notifications") {
            input "audioDevices", "capability.audioNotification", title: "Speak notifications on", required: false, multiple: true, submitOnChange: true, image: "https://www.rboyapps.com/images/Horn.png"
            if (audioDevices) {
                input "audioVolume", "number", title: "...at this volume level (optional)", description: "keep current", required: false, range: "1..100"
            }
            input("recipients", "contact", title: "Send notifications to", multiple: true, required: false) {
                input "push", "bool", title: "Push notifications", required: false, image: "https://www.rboyapps.com/images/PushNotification.png", submitOnChange: true
                if (!push) {
                    input "silentPush", "bool", title: "Silent notifications", required: false, image: "https://www.rboyapps.com/images/SilentNotification.png"
                }
                input "sms", "phone", title: "Send SMS notification to", required: false, image: "https://www.rboyapps.com/images/Notifications.png"
                paragraph "You can enter multiple phone numbers by separating them with a '*'. E.g. 5551234567*+18747654321"
            }
            input "textMessage", "text", title: "Use custom notification message", capitalization: "sentences", required: false
            paragraph "You can use the following custom labels in your message:\n<name> for triggering device name\n<rule> for rule name\n<status> for device status"
            input "repeatNotification", "number", title: "Notify every (minutes)", description: "Set for after or repeat notifications", range: "1..*", required: false, submitOnChange: true
            if (repeatNotification) {
                input "skipFirstNotification", "bool", title: "Skip initial notification", required: false
            }
        }
    }
}

private anySchedule() {
    def defined = false
    ('A'..'C').each { schedule ->
        if (settings."userDayOfWeek${schedule}${1}") {
            defined = true
        }
    }
    
    return defined
}

def scheduleCodesPage(params) {
    // params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
        log.trace "Passed from main page, using params lookup ${params}"
    } else if (atomicState.params) {
        params = atomicState.params
        log.trace "Passed from submitOnChange, atomicState lookup ${atomicState.params}"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def user = params?.user ?: ""
    def schedule = params?.schedule ?: ""

    log.trace "Schedule Codes Page, schedule:$schedule, user:$user, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"scheduleCodesPage", title: "Define schedule ${schedule}", uninstall: false, install: false) {
        section() {
            def i = user as Integer
            def priorUserDayOfWeek = settings."userDayOfWeek${schedule}${i}"
            def priorUserStartTime = settings."userStartTime${schedule}${i}"
            def priorUserEndTime = settings."userEndTime${schedule}${i}"
            log.debug "Schedule:$schedule, User:$i, UserDayOfWeek: $priorUserDayOfWeek, UserStartTime: $priorUserStartTime, UserEndTime: $priorUserEndTime"

            input "userStartTime${schedule}${i}", "time", title: "Start Time", required: false
            input "userEndTime${schedule}${i}", "time", title: "End Time", required: false
            input "userDayOfWeek${schedule}${i}",
                "enum",
                title: "Which day of the week?",
                description: "Not defined",
                required: false,
                multiple: true,
                options: [
                    'All Week',
                    'Monday to Friday',
                    'Saturday & Sunday',
                    'Monday',
                    'Tuesday',
                    'Wednesday',
                    'Thursday',
                    'Friday',
                    'Saturday',
                    'Sunday'
                ]
        }
    }
}

def installed() {
	log.debug "INSTALLED with $settings"
    if (isParent) {
        initializeParent()
    } else {
        initialize()
    }
}

def updated() {
	log.debug "UPDATED with $settings"
    if (isParent) {
        initializeParent()
    } else {
        initialize()
    }
}

// PARENT STUFF
def initializeParent(data = [:]) {
    log.trace "Initializing parent: $isParent"
    if (state.clientVersion && (state.clientVersion != clientVersion())) { // Check for platform outage (null)
        def msg = "${app.label} detected version upgrade, reinitializing all rules"
        log.warn msg
        sendPush(msg)
        getChildApps().each { child ->
            child.initialize(data)
        }
    }
    state.clientVersion = clientVersion() // Update our version
    state.parentInstalled = true

	unschedule()
	unsubscribe()

    subscribe(app, appTouchParent)

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("* 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm
}

def appTouchParent(evt) {
    log.trace "appTouchParent: $isParent"
    
    // Check if we have a version upgrade
    if (state.clientVersion && (state.clientVersion != clientVersion())) { // Check for platform outage (null)
        def msg = "${app.label} detected version upgrade, reinitializing"
        log.warn msg
        initializeParent([check: true]) // Notify
    } else {
        def msg = "App was reinitialized by the user, reinitializing all rules. name: ${evt.name}, value: ${evt.value}"
        log.info msg
        getChildApps().each { child ->
            child.checkDeviceStatesOffline() // Check for notifications offline
        }
    }
}

// CHILD RULES
def initialize(data = [:]) {
    log.trace "Initializing: $settings"
    
    state.clientVersion = clientVersion() // Update our version

	unschedule()
	unsubscribe()
    
    subscribe(location, "mode", modeChangeHandler)
    pushButtons ? subscribe(pushButtons, "button.pushed", triggerHandler) : ""
    pushButtons ? subscribe(pushButtons, "button.held", triggerHandler) : ""
    momentaries ? subscribe(momentaries, "momentary", triggerHandler) : ""
    openContacts ? subscribe(openContacts, "contact.open", triggerHandler) : ""
    closeContacts ? subscribe(closeContacts, "contact.closed", triggerHandler) : ""
    unlockedLocks ? subscribe(unlockedLocks, "lock.unlocked", triggerHandler) : ""
    unlockedLocks ? subscribe(unlockedLocks, "lock.unlocked with timeout", triggerHandler) : ""
    unlockedLocks ? subscribe(unlockedLocks, "lock.unknown", triggerHandler) : ""
    lockedLocks ? subscribe(lockedLocks, "lock.locked", triggerHandler) : ""
    lockedLocks ? subscribe(lockedLocks, "lock.unknown", triggerHandler) : ""
    switchOn ? subscribe(switchOn, "switch.on", triggerHandler) : ""
    switchOff ? subscribe(switchOff, "switch.off", triggerHandler) : ""
    motionOn ? subscribe(motionOn, "motion.active", triggerHandler) : ""
    waterSensors ? subscribe(waterSensors, "water.wet", triggerHandler) : ""
    smokeSensors ? subscribe(smokeSensors, "smoke.detected", triggerHandler) : ""
    coSensors ? subscribe(coSensors, "carbonMonoxide.detected", triggerHandler) : ""
    accelSensors ? subscribe(accelSensors, "acceleration.active", triggerHandler) : ""
    arrives ? subscribe(arrives, "presence.present", triggerHandler) : ""
    leaves ? subscribe(leaves, "presence.not present", triggerHandler) : ""
    tampers ? subscribe(tampers, "tamper.detected", triggerHandler) : ""
    
    if (data?.check) { // Was this an interrupted sensor notification?
        runIn(1, checkDeviceStates, [overwrite: true, data: [postText: "when ${app.label} was initialized"]]) // Do it offline so that if we aren't in the right mode, it won't run
    }
}

def modeChangeHandler(evt) {
    log.trace "Mode change detected, triggering check for device states: name: $evt.name, value: $evt.value"

    // Check if we have a version upgrade
    if (state.clientVersion && (state.clientVersion != clientVersion())) { // Check for platform outage (null)
        def msg = "${app.label} detected version upgrade, reinitializing all rules"
        log.warn msg
        parent.initializeParent([check: modeCheck]) // Check device states
        sendNotifications(msg)
        return
    }

    if (modeCheck) { // If we're requested to check sensors on a mode change
        checkDeviceStates([postText: "when mode was changed to ${evt.value}"])
    }
}

// Check device states offline so that if we aren't in the correct mode it won't execute
def checkDeviceStatesOffline(data = [:]) {
    runIn(1, checkDeviceStates, [overwrite: true, data: data]) 
}

// Check device states and notify if required
def checkDeviceStates(data = [:]) {
    log.trace "CheckDeviceStates: $data"
    
    // Momentary and buttons are time specific events so don't check their status, check state of remaining devices
    def postText = data?.postText
    def followUp = data?.followUp
    def evts = []
    def checks = [
        // Devices, Attribute, States
    	[ arrives, "presence", ["present"] ],
    	[ leaves, "presence", ["not present"] ],
    	[ openContacts, "contact", ["open"] ],
    	[ closeContacts, "contact", ["closed"] ],
    	[ unlockedLocks, "lock", ["unlocked","unlocked with timeout","unknown"] ],
    	[ lockedLocks, "lock", ["locked","unknown"] ],
    	[ switchOn, "switch", ["on"] ],
    	[ switchOff, "switch", ["off"] ],
    	[ motionOn, "motion", ["active"] ],
    	[ tampers, "tamper", ["detected"] ],
    	[ smokeSensors, "smoke", ["detected"] ],
    	[ coSensors, "carbonMonoxide", ["detected"] ],
    	[ waterSensors, "water", ["wet"] ],
        [ accelSensors, "acceleration", ["active"] ],
    ]
        
    checks.each { devs, attribute, states ->
        devs?.each { dev -> 
            if (states.contains(dev.currentValue(attribute))) { // Check if we have an event
                def evt = [displayName: dev.displayName, name: attribute, value: dev.currentValue(attribute), data: [postText: (followUp ? " ${((now() - dev.latestState(attribute).date.getTime())/60/1000 + 0.5) as Integer} minutes ago" : postText), followUp: followUp]] // If this is a follow up request, indicate how long it's been triggered
                //log.trace "Found active device state: $evt"
                evts << evt
            }
        }
    }
    
    // If we have triggers report them
    evts.each { evt ->
        triggerHandler(evt)
    }
}

def triggerHandler(evt) {
    log.trace "${evt?.displayName} triggered, name: ${evt?.name}, value: ${evt?.value}, data: ${evt?.data}"

    def data = (evt?.data instanceof String) ? parseJson(evt?.data) : (evt?.data ?: [:])

    // Check if we have a version upgrade
    if (state.clientVersion && (state.clientVersion != clientVersion())) { // Check for platform outage (null)
        def msg = "${app.label} detected version upgrade, reinitializing all rules"
        log.warn msg
        parent.initializeParent([check: true]) // Check device states for this interrupted event
        sendNotifications(msg)
        return
    }

    // Check if we are within any of the operating schedules
    if (anySchedule() && !('A'..'C').any { schedule -> checkSchedule(1, schedule) }) { // Check if we are within operating Schedule
        log.debug "Outside operating schedule, not triggered chimes"
        return
    }

    // If it's a button check if we have a restriction
    if (evt?.name == "button") {
        if (pushButtonsNumbers && data?.buttonNumber && !pushButtonsNumbers.any { (it as Integer) == 0 } && !pushButtonsNumbers.any { (it as Integer) == data?.buttonNumber }) { // Check if we have a button number and the user has selected some numbers
            log.warn "Ignoring button number ${data?.buttonNumber} from ${evt?.displayName} as it not part of selected button numbers ${pushButtonsNumbers}"
            return // We're done here
        }
    }
    
    // Ring chimes
    if (chimes) {
        log.info "Triggering Chimes: $chimes"
        chimes*.beep()
    } else {
        log.trace "No chimes configured"
    }
    
    // Send/play notifications
    def status = ""
    switch (evt?.value) {
        case "held":
        case "pushed":
        case "momentary":
            status += "was pressed"
            break
        case "open":
            status += "was opened"
            break
        case "closed":
            status += "was closed"
            break
        case "locked":
        	status += "was locked"
            break
        case "unlocked":
        case "unlocked with timeout":
        	status += "was unlocked"
            break
        case "unknown":
        	status += "was jammed or did not complete its operation"
            break
        case "on":
            status += "was turned on"
            break
        case "off":
            status += "was turned off"
            break
        case "present":
            status += "arrived"
            break
        case "not present":
            status += "left"
            break
        case "detected":
        	switch (evt.name) {
                case "tamper":
            		status += "detected tampering"
                	break
                case "smoke":
            		status += "detected smoke"
                    break
                case "carbonMonoxide":
            		status += "detected carbon monoxide"
                    break
                default:
            		status += "detected"
                    break
            }
            break
        case "active":
        	switch (evt.name) {
                case "motion":
                    status += "detected motion"
                    break
                case "acceleration":
            		status += "detected movement"
                    break
                default:
            		status += "detected"
                    break
            }
            break
        case "wet":
        	status += "detected water"
            break
        default:
        	status += "was triggered"
            break
    }
    
    // Check if we need to setup a repeat notification
    if (repeatNotification) {
        log.trace "Scheduling follow up check in $repeatNotification minutes"
        runIn(repeatNotification * 60, checkDeviceStates, [overwrite: true, data: [followUp: true]])
    }
    
    def msg = textMessage ? textMessage.replaceAll("<name>", evt?.displayName).replaceAll("<rule>", app.label).replaceAll("<status>", status) : "${evt?.displayName} $status"
    msg = data?.postText ? (msg + " " + data?.postText) : msg // Prefix a postText if we have one
    if (data?.followUp || !repeatNotification || (repeatNotification && !skipFirstNotification)) { // Incase we need to skip initial notification
        log.info msg
        sendNotifications(msg) // In the end as it may timeout
    } else {
        log.info "Skipping first notification: $msg"
    }
}

// Checks if we are within the current operating scheduled
// Inputs to the function are user (i) and schedule (x) (there can be multiple schedules)
// Preferences required in user input settings are:
// settings."userStartTime${x}${i}" - optional
// settings."userEndTime${x}${i}" - optional
// settings."userDayOfWeek${x}${i}" - required
private checkSchedule(def i, def x) {
    log.trace "Checking operating schedule $x for user $i"

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    def doChange = false
    Calendar localCalendar = Calendar.getInstance(timeZone)
    int currentDayOfWeek = localCalendar.get(Calendar.DAY_OF_WEEK)
    def currentDT = new Date(now())

    // some debugging in order to make sure things are working correclty
    log.trace "Current time: ${currentDT.format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Check if we are within operating times
    if (settings."userStartTime${x}${i}" && settings."userEndTime${x}${i}") {
        def scheduledStart = timeToday(settings."userStartTime${x}${i}", timeZone)
        def scheduledEnd = timeToday(settings."userEndTime${x}${i}", timeZone)

        if (scheduledEnd <= scheduledStart) { // End time is next day
            def localHour = currentDT.getHours() + (int)(timeZone.getOffset(currentDT.getTime()) / 1000 / 60 / 60)
            //log.trace "Local hour is $localHour"
            if (( localHour >= 0) && (localHour < 12)) // If we between midnight and midday
            {
                log.trace "End time is before start time and we are past midnight, assuming start time is previous day"
                scheduledStart = scheduledStart.previous() // Get the start time for yesterday
            } else {
                log.trace "End time is before start time and we are past midday, assuming end time is the next day"
                scheduledEnd = scheduledEnd.next() // Get the end time for tomorrow
            }
        }

        log.trace "Operating Start ${scheduledStart.format("HH:mm z", timeZone)}, End ${scheduledEnd.format("HH:mm z", timeZone)}"

        if (currentDT < scheduledStart || currentDT > scheduledEnd) {
            log.debug "Outside operating time schedule"
            return false
        }
    }

    // Check the condition under which we want this to run now
    // This set allows the most flexibility.
    log.trace "Operating DOW(s): ${settings."userDayOfWeek${x}${i}"}"

    if(!settings."userDayOfWeek${x}${i}") {
        log.debug "Day of week not specified for operating schedule $x for user $i"
        return false
    } else if(settings."userDayOfWeek${x}${i}".contains('All Week')) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Monday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.MONDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Tuesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.TUESDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Wednesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.WEDNESDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Thursday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.THURSDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Friday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.FRIDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Saturday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SATURDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Sunday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SUNDAY) {
        doChange = true
    }

    // If we have hit the condition to schedule this then lets do it
    if(doChange == true){
        log.debug("Within operating schedule")
        return true
    }
    else {
        log.debug("Outside operating schedule")
        return false
    }
}

private void sendText(number, message) {
    if (number) {
        def phones = number.replaceAll("[;,#]", "*").split("\\*") // Some users accidentally use ;,# instead of * and ST can't handle *,#+ in the number except for + at the beginning
        for (phone in phones) {
            try {
                sendSms(phone, message)
            } catch (Exception e) {
                sendPush "Invalid phone number $phone"
            }
        }
    }
}

private void sendNotifications(message) {
	if (!message) {
		return
    }
    
    if (location.contactBookEnabled) {
        sendNotificationToContacts(message, recipients)
    } else {
        if (push) {
            sendPush message
        } else if (silentPush) {
            sendNotificationEvent(message)
        }
        if (sms) {
            sendText(sms, message)
        }
    }

    audioDevices?.each { audioDevice -> // Play audio notifications
        if (audioDevice.hasCommand("playText")) { // Check if it supports TTS
            if (audioVolume) { // Only set volume if defined as it also resumes playback
                audioDevice.playTextAndResume(message, audioVolume)
            } else {
                audioDevice.playText(message)
            }
        } else {
            if (audioVolume) { // Only set volume if defined as it also resumes playback
                audioDevice.playTrackAndResume(textToSpeech(message)?.uri, audioVolume) // No translations at this time
            } else {
                audioDevice.playTrack(textToSpeech(message)?.uri) // No translations at this time
            }
        }
    }
}

def checkForCodeUpdate(evt = null) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "Chimes and Notifications for Doorbells and Sensors"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (updateNotifications != false) { // The default true may not be registered
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = 
                    [ pushButtons,
                     momentaries,
                     openContacts,
                     closeContacts,
                     unlockedLocks,
                     lockedLocks,
                     switchOn,
                     switchOff,
                     motionOn,
                     arrives,
                     leaves,
                     tampers,
                     waterSensors,
                     accelSensors,
                     smokeSensors,
                     coSensors ]
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device handler for ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (updateNotifications != false) { // The default true may not be registered
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}

// THIS IS THE END OF THE FILE